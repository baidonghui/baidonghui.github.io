---
layout: post
title: "JAVA数据结构和算法笔记（五）"
date: 2015-08-05 21:37:08
category: java
tags: 数据结构和算法
---
JAVA数据结构和算法的学习笔记。（图）
<!--more-->
#图
图是一种比树更复杂的非线性结构。在树中，节点间具有分支层次关系，每层的节点只能和上一层中的至多一个节点相关，但可能和下一层中的多个节点相关，不能和同一层的节点相关。而在图中，任意两个顶点之间都可能相关。

图通常有一个固定的形状，这是由物理和抽象的问题所决定的。例如，图中节点表示城市，而边可能表示城市间的航班信息。另一个更抽象的例子是一个代表了几个单独任务的图，这些任务是完成一个项目所必需的。在图中，节点可能代表任务，有向边指示某个任务必须在另一个任务前完成。在这种情况下图的形状取决于真实世界的具体情况。

##定义
**图**是有一个顶点集合$V_n$和边集合$E_n$组成，通常记为$G=(V_n, E_n)$。每条边都依附于两个顶点，图只是显示了顶点和边的关系——哪些边连接着哪些顶点。

在一个图中，如果顶点之间的连线是没有方向的，则称该图为**无向图**，$(v_i, v_j)$和$(v_j, v_i)$表示的是同一条边；如果两个顶点之间的边是有方向的，则称该图为**有向图**，用$< v_i, v_j >$表示由$v_i$指向$v_j$的边，有向边也称为**弧**。如果$v_i$和$v_j$之间存在边，则互相称之为**邻接点**，这条边称为$v_i$和$v_j$的**邻接边**。如果在无向图中任意两个顶点都有一条边直接相连，则称该图为**无向完全图**，如果在有向图中任意两顶点之间都有方向互为相反的两条弧相连接，则称为**有向完全图**。如果一个图接近完全图，则称为**稠密图**；如果边数很少，则称为**稀疏图**。**顶点的度**是指依附于某顶点的边数。在有向图中，顶点的度等于入度和出度之和。顶点$v_p$到$v_q$的**路径**是指一个从顶点$v_i$到$v_j$的顶点序列，序列中任两个相邻的顶点之间存在一条边，路径上边的数目称为**路径长度**。如果路径的起点和终点是同一个点，则该路径称为**回路**或**环**，若路径中的顶点不重复出现，则该路径称为**简单路径**，若除了第一个顶点和最后一个顶点之外，其他的顶点不重复出现的回路称为**简单回路**。若存在$V' \subset V, E' \subset E$，则$G' = (V', E')$称为$(V,E)$的**子图**。在无向图中，如果从一个顶点到另一个顶点有路径，则称这两个顶点是**连通的**，若图中任意两顶点都是连通的，则称该图是**连通图**，反之，如果不能从某个顶点到达另一个顶点，那么图就是非连通的，非连通图包含几个连通子图。

##图的存储
通常使用一个顶点类的对象表示一个顶点，顶点对象可以放在数组或链表中，采用邻接表和邻接矩阵来表示图：

邻接矩阵是一个二维数组，如果图有N个顶点，那么邻接矩阵就是$N \times N$的数组。

对于无权图，数组中的元素用1和0表示。

|   | A  |  B |  C | D  |
| ------------ | ------------ | ------------ | ------------ | ------------ |
|  A | 0  | 1  | 1 ○  | 1  |
|  B | 1  | 0  | 0  | 1  |
|  C | 1●  | 0  | 0  | 0  |
|  D | 1  | 1  | 0  | 0  |

邻接矩阵中○处的位置表示由顶点A能否直接到达顶点C，而●处的位置表示由顶点C能否直接到达顶点A。对于无向图而言，由于从一点可以到达另一点，从另一点也可以返回这点，因此邻接矩阵的上下三角形是对称的。

对于加权图而言，数组中的元素表示两点之间的权值，当不存在直接相连的边时用无穷大表示。

邻接表是链表的数组，或链表的链表。每个单独的链表表示了有哪些顶点与当前顶点临界。

| 顶点  | 包含邻接顶点的链表  |
| ------------ | ------------ |
| A  | B->C->D  |
| B  | A->D  |
| C  | A  |
| D  | A->B  |


##图的搜索

**深度优先搜索**（DFS）是通过栈实现的，它类似书中的先序遍历。

1. 访问一个邻接的未访问顶点，标记它，并把它放入栈中。
2. 当不能执行1时，从栈中弹出一个顶点，执行1。
3. 如果1、2都不能执行完成了整个搜索过程。

![Graph.traversal.example.svg](https://upload.wikimedia.org/wikipedia/commons/thumb/6/61/Graph.traversal.example.svg/200px-Graph.traversal.example.svg.png)
使用DFS遍历的结果为A，B，D，F，E，C，G。

DFS类似迷宫：迷宫有狭窄的过道（边）和过道的交汇点（顶点）组成

**广度优先搜索**（BFS）是通过队列实现的。

1. 访问一个未访问的邻接点，标记它，并把它放入队列。
2. 如果已经没有未访问的邻接点，则从队头取出一个顶点，并使其成为当前顶点。
3. 如果队列为空，则搜索结束。

同样对于上图而言，使用BFS所得的结果为A、B、C、E、D、F、G。

##生成树与最小生成树

设从连通图$G$中任一顶点出发，对图进行遍历时，必将边集合$E_n$分为两个部分：一个是遍历过程中经历的边的集合$T(G)$，另一部分是剩余的边的集合$B(G)$。顶点$V$和$T(G)$就构成了连通图$G$的**生成树**。对连通图的不同遍历，如遍历出发点或存储点的顺序不同，就可能得到不同的生成树，但生成树的边数量总是比顶点的数量小1，生成树可以使用DFS或BFS搜索，记录走过的边即可。对于非连通图，通过这样的遍历，得到的是**生成森林**。

如果无向连通图是一个带权图，那么，它的所有生成树中必有一棵是边的权值总和最小的生成树，我们将这棵生成树称为**最小代价生成树**，简称**最小生成树**。


Prim算法构造最小生成树：
已知一个图$G=(V_n,E_n)$，设置两个集合$U$和$T$分别用于存放最小生成树中的顶点和边。


1 $U=\lbrace u_{0} \rbrace , T=\lbrace \rbrace$

2 while($U \ne V_n$) 

2.1     $(u,v) = min \lbrace w_{uv} | u \in U , v \in  V_n - U \rbrace $;

2.2     $T = T + \lbrace (u,v) \rbrace$;

2.3     $U = U + \lbrace v \rbrace  \rbrace$;


Prim算法的思想是从所有的$u \in U$，$v \in V_n - U$的边中，选取权值最小的边，将顶点$v$加入到$U$中，将边$(u,v)$加入到$T$中。

Kruskal算法构造最小生成树：
Kruskal算法是按照边的权值递增的顺序构造最小生成树的方法，其基本思想是：已知一个图$G=(V_n,E_n)$，令最小生成树为$T=(V_T, E_T)$，初始值为$V_T =V_n$，$E_T=\lbrace \rbrace$。然后从$E_n - E_T$中不断选取权值最小的边，如果该边的两个顶点属于$T$的两个连通子图，则将此边作为最小生成树的边加入到$E_T$中，若该边的加入构成回路，则舍弃此边。


##拓扑排序
当一个图是有向无环图时，可以进行拓扑排序，但是排序的结果一般不唯一；而对于有向图存在环时，则不能进行拓扑排序。

选课问题，有些课程是需要其他课程的理论和知识。

1. 找到一个没有后继的顶点
2. 从图中删除这个顶点，在排序表中加入这个顶点。


##Dijkstra单源最短路径算法
给定带权有向图$G=(V_n,E_n)$和源点$v_m \in V_n$，求从$v_m$到$G$中其余各顶点的最短路径。

Dijkstra算法的思想是：设置两个顶点的集合$S$和$T=V_n -S$，集合$S$中存放已找到最短路径的顶点，集合$T$中存放还未找到最短路径的顶点。初始状态是$S= \lbrace v_m \rbrace $，然后不断的从$T$中选取路径长度最短的顶点$v_j$加入到集合$S$中，并检测是否修改从顶点$v_m$到集合T中剩余顶点的最短路径长度值：要比较原来保存的长度值和从$v_m$到$v_j$再到该顶点的路径长度。此过程不断的重复，直到所有顶点都加入到$S$中。



#参考
1. [Data Structures & Algortithms in Java](http://www.amazon.com/Data-Structures-Algorithms-Java-Edition/dp/0672324539)
2. [visualgo.net](http://visualgo.net)
3. [数据结构与算法第2版](http://baike.baidu.com/view/7256479.htm)
4. [Depth-first search](https://en.wikipedia.org/wiki/Depth-first_search)


